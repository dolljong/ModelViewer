<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Viewer</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; display: flex; flex-direction: column; height: 100vh; }
        #app-header { flex-shrink: 0; padding: 1rem; background-color: #1f2937; color: white; border-bottom: 2px solid #374151; }
        #main-content { display: flex; flex-grow: 1; min-height: 0; }
        #input-panel { flex-basis: 350px; flex-shrink: 0; padding: 1rem; background-color: #f3f4f6; overflow-y: auto; }
        #visualization-container { flex-grow: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #mct-input { height: 300px; resize: vertical; min-height: 150px; font-family: monospace; font-size: 10px; }
        
        /* --- Label Styles Start --- */
        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 캔버스 클릭/패닝이 가능하도록 이벤트 통과 */
            overflow: hidden;
            z-index: 90;
        }
        .node-label {
            position: absolute;
            color: #FFF; /* 흰색 텍스트 */
            background: rgba(0, 0, 0, 0.4); /* 반투명 검은색 배경 */
            padding: 1px 3px;
            font-size: 10px;
            font-family: monospace;
            border-radius: 2px;
            /* transform: translate(-50%, -50%); /* JS에서 위치를 계산하여 중앙 정렬 */
            white-space: nowrap;
            display: none; /* 체크박스로 토글하기 전까지 숨김 */
        }
        .element-label {
            position: absolute;
            color: #FFD700; /* 금색 텍스트 */
            background: rgba(0, 0, 50, 0.5); /* 반투명 남색 배경 */
            padding: 1px 3px;
            font-size: 10px;
            font-family: monospace;
            border-radius: 2px;
            white-space: nowrap;
            display: none; /* 체크박스로 토글하기 전까지 숨김 */
        }
        .section-label {
            position: absolute;
            color: #00FF88; /* 녹색 텍스트 */
            background: rgba(50, 0, 50, 0.5); /* 반투명 보라색 배경 */
            padding: 1px 3px;
            font-size: 10px;
            font-family: monospace;
            border-radius: 2px;
            white-space: nowrap;
            display: none;
        }
        /* --- Label Styles End --- */

        #info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 300px;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        #zoom-selection-rect {
            position: absolute;
            border: 2px dashed #00aaff;
            background: rgba(0, 170, 255, 0.1);
            pointer-events: none;
            z-index: 95;
            display: none;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <header id="app-header" class="text-xl font-bold rounded-b-lg">
        Model Viewer
    </header>
    
    <div id="main-content">
        <!-- Input Panel -->
        <div id="input-panel" class="space-y-4">
            <h2 class="text-lg font-semibold">MCT 데이터 입력</h2>

            <!-- Theme Toggle -->
            <div class="flex items-center justify-between">
                <label for="theme-select" class="text-sm font-medium">테마 모드:</label>
                <select id="theme-select" class="border border-gray-300 rounded-md px-2 py-1 text-sm focus:ring-blue-500 focus:border-blue-500">
                    <option value="dark">다크 모드</option>
                    <option value="light">라이트 모드</option>
                </select>
            </div>

            <textarea id="mct-input" class="w-full border border-gray-300 p-2 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="여기에 MCT 파일 내용을 붙여넣으세요 (*NODE 및 *ELEMENT 섹션 필수)"></textarea>

            <div class="flex gap-2">
                <button id="load-button" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-150">
                    3D 모델 로드
                </button>
                <button id="file-open-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-150">
                    파일 열기
                </button>
            </div>
            <input type="file" id="file-input" accept=".mct,.txt" class="hidden">

            <!-- View Controls -->
            <div class="flex gap-2">
                <button id="btn-fit-all" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1.5 px-3 rounded-lg text-sm transition duration-150">
                    전체 보기
                </button>
                <button id="btn-window-zoom" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1.5 px-3 rounded-lg text-sm transition duration-150">
                    윈도우 줌
                </button>
            </div>

            <!-- Perspective Toggle -->
            <div class="flex items-center">
                <input type="checkbox" id="toggle-perspective" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                <label for="toggle-perspective" class="ml-2 block text-sm text-gray-900">원근 투영 (Perspective)</label>
            </div>

            <!-- Node Label Toggle -->
            <div class="flex items-center">
                <input type="checkbox" id="toggle-labels" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                <label for="toggle-labels" class="ml-2 block text-sm text-gray-900">노드 번호 표시</label>
            </div>
            <p class="text-xs text-gray-500 -mt-2">참고: 노드 수가 많으면 성능이 저하될 수 있습니다.</p>

            <!-- Element Label Toggle -->
            <div class="flex items-center">
                <input type="checkbox" id="toggle-element-labels" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                <label for="toggle-element-labels" class="ml-2 block text-sm text-gray-900">부재 번호 표시</label>
            </div>

            <!-- Section Label Toggle -->
            <div class="flex items-center">
                <input type="checkbox" id="toggle-section-labels" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                <label for="toggle-section-labels" class="ml-2 block text-sm text-gray-900">단면 번호 표시</label>
            </div>


            <div id="status-message" class="text-sm mt-2 text-gray-700"></div>
        </div>

        <!-- Visualization Container -->
        <div id="visualization-container">
            <!-- Container for persistent node labels -->
            <div id="label-container"></div>

            <!-- Container for hover info -->
            <div id="info-overlay"></div>
            
            <div id="zoom-selection-rect"></div>

            <div id="instructions">
                <p><strong>상호작용 가이드:</strong></p>
                <ul class="list-disc list-inside ml-2">
                    <li>마우스 좌클릭 + 드래그: 회전</li>
                    <li>마우스 우클릭 + 드래그 (또는 Alt/Ctrl + 좌클릭): 이동 (패닝)</li>
                    <li>마우스 휠: 확대/축소 (Zoom)</li>
                    <li>마우스 커서를 노드/요소 위에 올리면 정보 표시</li>
                </ul>
                <p class="mt-2 text-xs font-bold text-red-500">
                    좌표계: X-축(종방향), Y-축(횡방향), Z-축(수직)
                </p>
            </div>
        </div>
    </div>

    <script>
        // Three.js Global Variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let INTERSECTED = null;
        let nodesPoints = null; 
        const INFO_OVERLAY = document.getElementById('info-overlay');
        const VIS_CONTAINER = document.getElementById('visualization-container');
        const STATUS_MESSAGE = document.getElementById('status-message');
        const LABEL_CONTAINER = document.getElementById('label-container'); // Label container
        
        // Node and Element Visual Properties
        const NODE_SIZE = 5; 
        let BEAM_RADIUS = 0.05;
        const NODE_COLOR = 0xff0000; 
        const BEAM_COLOR = 0x0000ff; 
        const HIGHLIGHT_COLOR = 0xffff00; 

        let globalNodesData = {};
        
        // Debugging variables moved to global scope
        let firstElementLine = "";
        let firstElementParsingResult = null;
        
        // Array to store node labels and their 3D positions
        let nodeLabels = [];
        // Array to store element labels and their 3D positions
        let elementLabels = [];
        // Array to store section labels and their 3D positions
        let sectionLabels = [];

        // Global bounds for fitAll
        let globalBounds = null;

        // Axis helper
        let axisScene, axisCamera;

        // Window zoom state
        let windowZoomActive = false;
        let zoomDragStart = null;

        // --- Theme Configuration (Graphics area only) ---
        const THEMES = {
            dark: {
                sceneBackground: 0x222222,
                instructionsBg: 'rgba(0,0,0,0.8)',
                instructionsText: '#ffffff',
                infoBg: 'rgba(0,0,0,0.7)',
                infoText: '#ffffff',
                nodeLabelBg: 'rgba(0, 0, 0, 0.4)',
                nodeLabelText: '#FFF',
                elementLabelBg: 'rgba(0, 0, 50, 0.5)',
                elementLabelText: '#FFD700',
                sectionLabelBg: 'rgba(50, 0, 50, 0.5)',
                sectionLabelText: '#00FF88',
            },
            light: {
                sceneBackground: 0xffffff,
                instructionsBg: 'rgba(255,255,255,0.9)',
                instructionsText: '#333333',
                infoBg: 'rgba(255,255,255,0.85)',
                infoText: '#111827',
                nodeLabelBg: 'rgba(255, 255, 255, 0.8)',
                nodeLabelText: '#111827',
                elementLabelBg: 'rgba(255, 255, 200, 0.85)',
                elementLabelText: '#92400e',
                sectionLabelBg: 'rgba(220, 255, 240, 0.85)',
                sectionLabelText: '#065f46',
            }
        };

        function applyTheme(mode) {
            const theme = THEMES[mode];
            if (!theme) return;

            // 3D scene background
            if (scene) {
                scene.background = new THREE.Color(theme.sceneBackground);
            }

            // Instructions panel
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.style.background = theme.instructionsBg;
                instructions.style.color = theme.instructionsText;
            }

            // Info overlay
            const infoOverlay = document.getElementById('info-overlay');
            if (infoOverlay) {
                infoOverlay.style.background = theme.infoBg;
                infoOverlay.style.color = theme.infoText;
            }

            // Node labels
            document.querySelectorAll('.node-label').forEach(el => {
                el.style.background = theme.nodeLabelBg;
                el.style.color = theme.nodeLabelText;
            });

            // Element labels
            document.querySelectorAll('.element-label').forEach(el => {
                el.style.background = theme.elementLabelBg;
                el.style.color = theme.elementLabelText;
            });

            // Section labels
            document.querySelectorAll('.section-label').forEach(el => {
                el.style.background = theme.sectionLabelBg;
                el.style.color = theme.sectionLabelText;
            });

            // Save to localStorage
            localStorage.setItem('modelviewer-theme', mode);
        }

        // --- MCT 데이터 파싱 함수 (강화된 로직) ---
        function parseMCT(mctText) {
            const nodes = {};
            const elements = {};
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            
            // Reset global debug variables
            firstElementLine = "";
            firstElementParsingResult = null;
            let lengthUnit = "M"; // 기본값

            // 0. *UNIT 파싱 (주석 제거 전 원본에서)
            const rawLines = mctText.split('\n');
            for (let i = 0; i < rawLines.length; i++) {
                const trimmed = rawLines[i].replace(/;.*/, '').trim();
                if (trimmed.toUpperCase() === '*UNIT') {
                    // 다음 데이터 라인에서 단위 읽기 (FORCE, LENGTH, HEAT, TEMPER 순)
                    for (let j = i + 1; j < rawLines.length; j++) {
                        const dataLine = rawLines[j].replace(/;.*/, '').trim();
                        if (dataLine.length === 0) continue;
                        if (dataLine.startsWith('*')) break;
                        const parts = dataLine.split(',').map(p => p.trim().toUpperCase());
                        if (parts.length >= 2) {
                            lengthUnit = parts[1]; // 두 번째가 LENGTH 단위
                        }
                        break;
                    }
                    break;
                }
            }

            // 1. MCT 텍스트를 라인별로 분리하고, 주석을 제거하며 공백 정리
            const allLines = mctText.split('\n')
                .map(line => {
                    const commentIndex = line.indexOf(';');
                    return (commentIndex !== -1 ? line.substring(0, commentIndex) : line).trim();
                })
                .filter(line => line.length > 0);

            // 2. 파싱할 섹션 키워드 및 종료 키워드 정의
            const SECTION_KEYWORDS = ["*NODE", "*ELEMENT"];
            // *ELEMENT 섹션을 종료시키는 키워드 목록
            const TERMINATION_KEYWORDS = [
                "*MATERIAL", "*SECT-PSCVALUE", "*SECTION", "*CONSTRAINT", 
                "*ELASTICLINK", "*RIGIDLINK", "*LOADTOMASS", "*EIGEN-CTRL", 
                "*USE-STLD", "*SFUNCTION", "*SPLDCASE", "*ENDDATA"
            ];

            // 3. 섹션 인덱스 찾기
            let nodeStartIndex = -1, elementStartIndex = -1, elementEndIndex = -1;

            allLines.forEach((line, index) => {
                const upperLine = line.toUpperCase();
                if (upperLine === "*NODE") {
                    nodeStartIndex = index + 1;
                } else if (upperLine === "*ELEMENT") {
                    elementStartIndex = index + 1;
                } else if (elementStartIndex > -1 && elementEndIndex === -1 && TERMINATION_KEYWORDS.includes(upperLine)) {
                    elementEndIndex = index;
                }
            });

            // *ELEMENT 섹션이 끝까지 계속될 경우 (파일 끝)
            if (elementStartIndex > -1 && elementEndIndex === -1) {
                elementEndIndex = allLines.length;
            }

            // --- 4. Node 파싱 ---
            if (nodeStartIndex === -1) {
                throw new Error("MCT 파일에서 *NODE 섹션을 찾을 수 없습니다.");
            }
            
            let nodeEndIndex = (elementStartIndex > -1) ? elementStartIndex - 1 : allLines.length;
            const nodeLines = allLines.slice(nodeStartIndex, nodeEndIndex);

            nodeLines.forEach(line => {
                const parts = line.split(',').map(p => p.trim()).filter(p => p !== '');
                if (parts.length >= 4) {
                    const iNO = parseInt(parts[0]);
                    const X = parseFloat(parts[1]);
                    const Y = parseFloat(parts[2]);
                    const Z = parseFloat(parts[3]);

                    if (!isNaN(iNO) && !isNaN(X) && !isNaN(Y) && !isNaN(Z)) {
                        nodes[iNO] = { X, Y, Z, iNO };
                        minX = Math.min(minX, X); maxX = Math.max(maxX, X);
                        minY = Math.min(minY, Y); maxY = Math.max(maxY, Y);
                        minZ = Math.min(minZ, Z); maxZ = Math.max(maxZ, Z);
                    }
                }
            });

            globalNodesData = nodes;

            if (Object.keys(nodes).length === 0) {
                 throw new Error("파싱된 유효한 노드 데이터가 없습니다.");
            }

            // --- 5. Element 파싱 ---
            if (elementStartIndex === -1) {
                console.warn("MCT 파일에서 *ELEMENT 섹션을 찾지 못했습니다.");
            } else {
                const elementLines = allLines.slice(elementStartIndex, elementEndIndex);
                
                elementLines.forEach(line => {
                    const parts = line.split(',').map(p => p.trim());
                    
                    if (parts.length >= 6) {
                        const iEL = parseInt(parts[0]);
                        const nodeI = parseInt(parts[4]);
                        const nodeJ = parseInt(parts[5]);
                        const elementType = parts[1] || "UNKNOWN";
                        const sectionNum = parseInt(parts[3]) || 0;

                        if (firstElementLine === "") {
                            firstElementLine = line;
                            firstElementParsingResult = { iEL, elementType, nodeI, nodeJ };
                        }

                        if (!isNaN(iEL) && !isNaN(nodeI) && !isNaN(nodeJ) && globalNodesData[nodeI] && globalNodesData[nodeJ]) {
                            elements[iEL] = {
                                iEL,
                                nodeI,
                                nodeJ,
                                type: elementType.trim(),
                                section: sectionNum
                            };
                        }
                    }
                });
            }
            
            console.log("--- Element Parsing Debug Info ---");
            console.log("First Element Line Found:", firstElementLine);
            console.log("Parsing Result (First Elem):", firstElementParsingResult);
            
            return { nodes, elements, bounds: { minX, maxX, minY, maxY, minZ, maxZ }, lengthUnit };
        }

        // 2. 3D Scene Initialization Function
        function initScene() {
            while(VIS_CONTAINER.firstChild) {
                if (VIS_CONTAINER.firstChild.tagName === 'CANVAS') {
                    if (controls) controls.dispose();
                    renderer.dispose();
                }
                VIS_CONTAINER.removeChild(VIS_CONTAINER.firstChild);
            }

            // Re-create label container
            const labelContainer = document.createElement('div');
            labelContainer.id = 'label-container';
            VIS_CONTAINER.appendChild(labelContainer);
            // Re-create info overlay
            const infoOverlay = document.createElement('div');
            infoOverlay.id = 'info-overlay';
            VIS_CONTAINER.appendChild(infoOverlay);
            // Re-create instructions
            const instructions = document.createElement('div');
            instructions.id = 'instructions';
            instructions.innerHTML = `
                <p><strong>상호작용 가이드:</strong></p>
                <ul class="list-disc list-inside ml-2">
                    <li>마우스 좌클릭 + 드래그: 회전</li>
                    <li>마우스 우클릭 + 드래그 (또는 Alt/Ctrl + 좌클릭): 이동 (패닝)</li>
                    <li>마우스 휠: 확대/축소 (Zoom)</li>
                    <li>마우스 커서를 노드/요소 위에 올리면 정보 표시</li>
                </ul>
                <p class="mt-2 text-xs font-bold text-red-500">
                    좌표계: X-축(종방향), Y-축(횡방향), Z-축(수직)
                </p>`;
            VIS_CONTAINER.appendChild(instructions);

            // Re-create zoom selection rectangle
            const zoomRect = document.createElement('div');
            zoomRect.id = 'zoom-selection-rect';
            VIS_CONTAINER.appendChild(zoomRect);

            // Scene Setup
            scene = new THREE.Scene();
            const savedTheme = localStorage.getItem('modelviewer-theme') || 'dark';
            scene.background = new THREE.Color(THEMES[savedTheme].sceneBackground);
            
            // Camera Setup (Orthographic by default)
            const aspect = VIS_CONTAINER.clientWidth / VIS_CONTAINER.clientHeight;
            const defaultSize = 100;
            camera = new THREE.OrthographicCamera(
                -defaultSize * aspect, defaultSize * aspect,
                defaultSize, -defaultSize,
                0.1, 100000
            );
            camera.up.set(0, 0, 1); // Z-up
            camera.position.set(-100, -100, 50);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(VIS_CONTAINER.clientWidth, VIS_CONTAINER.clientHeight);
            // Insert canvas as the *first* child, so labels overlay it
            VIS_CONTAINER.prepend(renderer.domElement);
            
            // Controls Setup
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };
            } else {
                console.error("OrbitControls failed to load.");
            }

            // Lighting Setup
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 300, 100); 
            scene.add(directionalLight);
            
            // Raycaster and Mouse Vector Initialization
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        }

        // 3. Structure Visualization Function
        function visualizeStructure(data) {
            // Clear existing objects but keep lights
            if (scene) {
                const childrenToRemove = scene.children.filter(child => child.isMesh || child.isPoints || child.isLine);
                childrenToRemove.forEach(child => {
                    scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            } else {
                initScene();
            }

            // Clear previous labels
            const labelContainer = document.getElementById('label-container');
            if (labelContainer) {
                labelContainer.innerHTML = '';
            }
            nodeLabels = [];
            elementLabels = [];
            sectionLabels = [];

            const nodes = data.nodes;
            const elements = data.elements;
            const bounds = data.bounds;
            globalBounds = bounds;

            // 단위에 따른 부재 굵기 조절
            const sizeX = bounds.maxX - bounds.minX;
            const sizeY = bounds.maxY - bounds.minY;
            const sizeZ = bounds.maxZ - bounds.minZ;
            const maxSpan = Math.max(sizeX, sizeY, sizeZ) || 1;
            BEAM_RADIUS = maxSpan * 0.001; // 모델 크기의 0.1%

            // Calculate 3D Model Center
            const center = new THREE.Vector3(
                (bounds.minX + bounds.maxX) / 2,
                (bounds.minY + bounds.maxY) / 2,
                (bounds.minZ + bounds.maxZ) / 2
            );
            
            // 3.1. Create Nodes (Points - Relative Size)
            const nodeMaterial = new THREE.PointsMaterial({ 
                color: NODE_COLOR, 
                size: NODE_SIZE, 
                sizeAttenuation: false, 
                depthTest: false,
                transparent: true
            });
            
            const nodePositions = [];
            const nodeIds = []; 

            for (const iNO in nodes) {
                const node = nodes[iNO];
                // Coordinate transformation
                nodePositions.push(node.X, node.Y, node.Z);
                nodeIds.push(node.iNO); 
                
                // --- Create DOM Label ---
                const labelDiv = document.createElement('div');
                labelDiv.className = 'node-label';
                labelDiv.textContent = iNO;
                labelContainer.appendChild(labelDiv);
                
                // Store label and its 3D position (Three.js coordinates)
                const position = new THREE.Vector3(node.X, node.Y, node.Z);
                nodeLabels.push({ element: labelDiv, position: position });
            }
            
            const nodeGeometry = new THREE.BufferGeometry();
            nodeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));
            
            nodesPoints = new THREE.Points(nodeGeometry, nodeMaterial);
            nodesPoints.userData = { ids: nodeIds, type: 'NodesGroup' }; 
            nodesPoints.renderOrder = 1; 
            scene.add(nodesPoints);


            // 3.2. Create Elements (Thin Cylinders - Mesh)
            const beamMaterial = new THREE.MeshBasicMaterial({ color: BEAM_COLOR });

            for (const iEL in elements) {
                const element = elements[iEL];
                const posI = nodes[element.nodeI];
                const posJ = nodes[element.nodeJ];

                if (posI && posJ) {
                    const startPoint = new THREE.Vector3(posI.X, posI.Y, posI.Z);
                    const endPoint = new THREE.Vector3(posJ.X, posJ.Y, posJ.Z);
                    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
                    const length = direction.length();
                    direction.normalize();
                    const elementRadius = BEAM_RADIUS;
                    const geometry = new THREE.CylinderGeometry(elementRadius, elementRadius, length, 8);
                    const mesh = new THREE.Mesh(geometry, beamMaterial.clone());
                    mesh.position.copy(startPoint).add(direction.clone().multiplyScalar(length / 2));
                    const axis = new THREE.Vector3(0, 1, 0); 
                    mesh.quaternion.setFromUnitVectors(axis, direction);

                    mesh.userData = {
                        id: iEL,
                        type: 'Element',
                        nodeI: element.nodeI,
                        nodeJ: element.nodeJ,
                        elementType: element.type,
                        section: element.section,
                        originalColor: BEAM_COLOR
                    };
                    scene.add(mesh);

                    // --- Create Element Label at midpoint ---
                    const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
                    const elemLabelDiv = document.createElement('div');
                    elemLabelDiv.className = 'element-label';
                    elemLabelDiv.textContent = iEL;
                    labelContainer.appendChild(elemLabelDiv);
                    elementLabels.push({ element: elemLabelDiv, position: midPoint });

                    // --- Create Section Label at midpoint ---
                    const secLabelDiv = document.createElement('div');
                    secLabelDiv.className = 'section-label';
                    secLabelDiv.textContent = element.section;
                    labelContainer.appendChild(secLabelDiv);
                    sectionLabels.push({ element: secLabelDiv, position: midPoint.clone() });
                } else {
                    console.warn(`Element ${iEL} skipped: Node ${element.nodeI} or ${element.nodeJ} not found.`);
                }
            }

            // 3.3. Adjust Camera and Controls
            if (controls) {
                const sizeX = bounds.maxX - bounds.minX;
                const sizeY = bounds.maxY - bounds.minY;
                const sizeZ = bounds.maxZ - bounds.minZ;
                const maxSize = Math.max(sizeX, sizeY, sizeZ);
                const distance = maxSize * 1.5 || 100;

                camera.position.set(center.x - distance, center.y - distance, center.z + distance / 2);
                controls.target.copy(center);
                
                camera.near = distance / 100;
                camera.far = distance * 10;
                camera.updateProjectionMatrix();

                controls.update();
            }

            // Update Status Message
            const numElements = Object.keys(elements).length;
            const numNodes = Object.keys(nodes).length;

            const firstElemResult = firstElementParsingResult ? ` | 첫 요소 파싱: [${firstElementLine}] -> ID: ${firstElementParsingResult.iEL}, N1: ${firstElementParsingResult.nodeI}, N2: ${firstElementParsingResult.nodeJ}` : " | (파싱된 요소 없음)";
            const debugInfo = `로드 성공! 노드: ${numNodes}개, 요소: ${numElements}개` + firstElemResult;

            STATUS_MESSAGE.textContent = debugInfo;
            console.log("Full Debug Info:", debugInfo);

            // Re-apply current theme after DOM elements are recreated
            const currentTheme = document.getElementById('theme-select').value;
            applyTheme(currentTheme);

            if (numElements === 0 && numNodes > 0) {
                 STATUS_MESSAGE.className = 'text-sm mt-2 text-orange-400 font-semibold';
            } else if (numElements === 0 && numNodes === 0) {
                 STATUS_MESSAGE.textContent = `오류: 파싱된 노드/요소 데이터가 없습니다. 입력 데이터를 확인해주세요.`;
                 STATUS_MESSAGE.className = 'text-sm mt-2 text-red-600 font-semibold';
            } else {
                 STATUS_MESSAGE.className = 'text-sm mt-2 text-green-600 font-semibold';
            }
        }
        
        // --- Axis Helper (좌표축 아이콘) ---
        function initAxisHelper() {
            axisScene = new THREE.Scene();
            axisCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 10);
            axisCamera.position.set(0, 0, 4);
            axisCamera.lookAt(0, 0, 0);

            const axisLen = 1;
            const headLen = 0.25;
            const headW = 0.1;

            // X axis - Red
            const arrowX = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0),
                axisLen, 0xff0000, headLen, headW
            );
            axisScene.add(arrowX);

            // Y axis - Green
            const arrowY = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0),
                axisLen, 0x00cc00, headLen, headW
            );
            axisScene.add(arrowY);

            // Z axis - Blue
            const arrowZ = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0),
                axisLen, 0x0066ff, headLen, headW
            );
            axisScene.add(arrowZ);
        }

        function createAxisLabels() {
            // 기존 라벨 제거
            document.querySelectorAll('.axis-label').forEach(el => el.remove());

            const labels = [
                { text: 'X', color: '#ff0000', dir: new THREE.Vector3(1, 0, 0) },
                { text: 'Y', color: '#00cc00', dir: new THREE.Vector3(0, 1, 0) },
                { text: 'Z', color: '#0066ff', dir: new THREE.Vector3(0, 0, 1) },
            ];
            const axisLabelEls = [];
            labels.forEach(l => {
                const div = document.createElement('div');
                div.className = 'axis-label';
                div.textContent = l.text;
                div.style.cssText = `position:absolute;color:${l.color};font-size:12px;font-weight:bold;font-family:monospace;pointer-events:none;z-index:101;`;
                VIS_CONTAINER.appendChild(div);
                axisLabelEls.push({ element: div, dir: l.dir });
            });
            return axisLabelEls;
        }

        let axisLabelEls = [];

        function updateAxisLabels() {
            if (!axisCamera || axisLabelEls.length === 0) return;
            const size = 120;
            const h = VIS_CONTAINER.clientHeight;
            for (const label of axisLabelEls) {
                // 축 끝점(3D)을 axisCamera로 투영
                const v = label.dir.clone().project(axisCamera);
                const sx = (v.x * 0.5 + 0.5) * size;
                const sy = (1 - (v.y * 0.5 + 0.5)) * size;
                label.element.style.left = (sx - 4) + 'px';
                label.element.style.top = (h - size + sy - 6) + 'px';
            }
        }

        // 4. Animation/Rendering Loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            // Update labels on every frame
            updateLabels();

            if (renderer && scene && camera) {
                // 메인 씬 렌더링
                renderer.render(scene, camera);

                // 좌표축 아이콘 렌더링 (좌하단 120x120)
                if (axisScene && axisCamera) {
                    // 메인 카메라의 회전(quaternion)을 축 카메라에 동기화
                    axisCamera.quaternion.copy(camera.quaternion);
                    axisCamera.position.set(0, 0, 4).applyQuaternion(camera.quaternion);

                    const axisSize = 120;
                    renderer.setViewport(0, 0, axisSize, axisSize);
                    renderer.setScissor(0, 0, axisSize, axisSize);
                    renderer.setScissorTest(true);
                    renderer.clearDepth();
                    renderer.render(axisScene, axisCamera);

                    // 뷰포트 복원
                    const w = VIS_CONTAINER.clientWidth;
                    const h = VIS_CONTAINER.clientHeight;
                    renderer.setViewport(0, 0, w, h);
                    renderer.setScissor(0, 0, w, h);
                    renderer.setScissorTest(false);

                    updateAxisLabels();
                }
            }
        }

        // --- New Function: Update Labels ---
        function updateLabels() {
            const showNodeLabels = document.getElementById('toggle-labels').checked;
            const showElementLabels = document.getElementById('toggle-element-labels').checked;
            const showSectionLabels = document.getElementById('toggle-section-labels').checked;
            if (nodeLabels.length === 0 && elementLabels.length === 0 && sectionLabels.length === 0) return;

            const width = VIS_CONTAINER.clientWidth;
            const height = VIS_CONTAINER.clientHeight;
            const widthHalf = width / 2;
            const heightHalf = height / 2;

            // Update node labels
            for (const label of nodeLabels) {
                if (!showNodeLabels) {
                    label.element.style.display = 'none';
                    continue;
                }

                const vector = label.position.clone().project(camera);

                if (vector.z > 1) {
                    label.element.style.display = 'none';
                    continue;
                }

                const x = (vector.x * widthHalf) + widthHalf;
                const y = -(vector.y * heightHalf) + heightHalf;

                if (x < -50 || x > width + 50 || y < -50 || y > height + 50) {
                    label.element.style.display = 'none';
                } else {
                    label.element.style.display = 'block';
                    label.element.style.transform = `translate(${x}px, ${y - 10}px)`;
                }
            }

            // Update element labels
            for (const label of elementLabels) {
                if (!showElementLabels) {
                    label.element.style.display = 'none';
                    continue;
                }

                const vector = label.position.clone().project(camera);

                if (vector.z > 1) {
                    label.element.style.display = 'none';
                    continue;
                }

                const x = (vector.x * widthHalf) + widthHalf;
                const y = -(vector.y * heightHalf) + heightHalf;

                if (x < -50 || x > width + 50 || y < -50 || y > height + 50) {
                    label.element.style.display = 'none';
                } else {
                    label.element.style.display = 'block';
                    label.element.style.transform = `translate(${x}px, ${y - 10}px)`;
                }
            }

            // Update section labels
            for (const label of sectionLabels) {
                if (!showSectionLabels) {
                    label.element.style.display = 'none';
                    continue;
                }

                const vector = label.position.clone().project(camera);

                if (vector.z > 1) {
                    label.element.style.display = 'none';
                    continue;
                }

                const x = (vector.x * widthHalf) + widthHalf;
                const y = -(vector.y * heightHalf) + heightHalf;

                if (x < -50 || x > width + 50 || y < -50 || y > height + 50) {
                    label.element.style.display = 'none';
                } else {
                    label.element.style.display = 'block';
                    label.element.style.transform = `translate(${x}px, ${y + 5}px)`;
                }
            }
        }
        
        // 5. Mouse Interaction (Raycasting)
        function onMouseMove(event) {
            if (!renderer || !raycaster) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            checkIntersection();
        }

        // 6. Check Object Intersection
        function checkIntersection() {
            if (!raycaster || !scene || !camera) return;

            raycaster.setFromCamera(mouse, camera);
            
            raycaster.params.Points.threshold = NODE_SIZE / (window.innerHeight / 2);

            const intersectableObjects = scene.children.filter(obj => obj.isPoints || (obj.isMesh && obj.userData.type === 'Element'));
            const intersects = raycaster.intersectObjects(intersectableObjects, false);
            
            const infoOverlay = document.getElementById('info-overlay'); // Get overlay element again

            // Restore previous intersected object color
            if (INTERSECTED) {
                if (INTERSECTED.isMesh) { 
                    INTERSECTED.material.color.set(BEAM_COLOR);
                } else if (INTERSECTED.isPoints) { 
                    INTERSECTED.material.color.set(NODE_COLOR);
                }
                INTERSECTED.material.needsUpdate = true;
                INTERSECTED = null;
                if (infoOverlay) infoOverlay.style.opacity = 0;
            }


            if (intersects.length > 0) {
                let object = intersects[0].object;
                let index = intersects[0].index;

                // Node Point Group
                if (object.isPoints && object.userData.type === 'NodesGroup' && index !== undefined) {
                    INTERSECTED = object; 
                    object.material.color.set(HIGHLIGHT_COLOR); 
                    object.material.needsUpdate = true;
                    
                    const nodeId = object.userData.ids[index];
                    const node = globalNodesData[nodeId];

                    if (node && infoOverlay) {
                        infoOverlay.style.opacity = 1;
                        infoOverlay.innerHTML = `
                            <strong>Node ID:</strong> ${nodeId}<br>
                            <strong>MCT 좌표 (X, Y, Z):</strong> ${node.X.toFixed(2)}, ${node.Y.toFixed(2)}, ${node.Z.toFixed(2)}
                        `;
                    }
                } 
                // Element Mesh (Cylinder)
                else if (object.isMesh && object.userData.type === 'Element') {
                    INTERSECTED = object;
                    INTERSECTED.material.color.set(HIGHLIGHT_COLOR);
                    INTERSECTED.material.needsUpdate = true;

                    if (infoOverlay) {
                        infoOverlay.style.opacity = 1;
                        const data = INTERSECTED.userData;
                        
                        infoOverlay.innerHTML = `
                            <strong>Element ID:</strong> ${data.id}<br>
                            <strong>연결 노드:</strong> ${data.nodeI} -> ${data.nodeJ}<br>
                            <strong>Element Type:</strong> ${data.elementType}<br>
                            <strong>단면 번호:</strong> ${data.section}
                        `;
                    }
                }
            } 
        }

        // 7. Window Resize Handler
        function onWindowResize() {
            if (camera && renderer && VIS_CONTAINER) {
                const w = VIS_CONTAINER.clientWidth;
                const h = VIS_CONTAINER.clientHeight;
                if (camera.isPerspectiveCamera) {
                    camera.aspect = w / h;
                } else {
                    const oldH = camera.top - camera.bottom;
                    const newAspect = w / h;
                    const halfH = oldH / 2;
                    camera.left = -halfH * newAspect;
                    camera.right = halfH * newAspect;
                }
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            }
        }
        
        // --- Camera Switch (Perspective ↔ Orthographic) ---
        function switchCamera(usePerspective) {
            const pos = camera.position.clone();
            const target = controls.target.clone();
            const dist = pos.distanceTo(target);
            const aspect = VIS_CONTAINER.clientWidth / VIS_CONTAINER.clientHeight;

            if (usePerspective) {
                camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100000);
            } else {
                // Ortho 크기: 현재 perspective에서 보이는 영역 기준
                const fovRad = (camera.isPerspectiveCamera) ? camera.fov * Math.PI / 180 : 1;
                const halfH = (camera.isPerspectiveCamera) ? dist * Math.tan(fovRad / 2) : camera.top;
                const halfW = halfH * aspect;
                camera = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, 0.1, 100000);
            }

            camera.up.set(0, 0, 1); // Z-up
            camera.position.copy(pos);
            camera.lookAt(target);

            // OrbitControls 재생성
            controls.dispose();
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.copy(target);
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            controls.update();
        }

        // --- Fit All ---
        function fitAll() {
            if (!globalBounds || !camera || !controls) return;
            const bounds = globalBounds;
            const center = new THREE.Vector3(
                (bounds.minX + bounds.maxX) / 2,
                (bounds.minY + bounds.maxY) / 2,
                (bounds.minZ + bounds.maxZ) / 2
            );
            const sizeX = bounds.maxX - bounds.minX;
            const sizeY = bounds.maxY - bounds.minY;
            const sizeZ = bounds.maxZ - bounds.minZ;
            const radius = Math.sqrt(sizeX * sizeX + sizeY * sizeY + sizeZ * sizeZ) / 2;

            // 카메라 방향 유지
            const currentDir = new THREE.Vector3().subVectors(camera.position, controls.target);
            if (currentDir.length() < 0.001) currentDir.set(-1, -1, 0.5);
            currentDir.normalize();

            if (camera.isPerspectiveCamera) {
                const fovRad = camera.fov * Math.PI / 180;
                const aspect = camera.aspect;
                const distV = radius / Math.sin(fovRad / 2);
                const distH = radius / Math.sin(Math.atan(Math.tan(fovRad / 2) * aspect));
                const distance = Math.max(distV, distH);
                controls.target.copy(center);
                camera.position.copy(center).add(currentDir.clone().multiplyScalar(distance));
                camera.near = distance / 100;
                camera.far = distance * 10;
            } else {
                const aspect = VIS_CONTAINER.clientWidth / VIS_CONTAINER.clientHeight;
                const halfH = radius * 1.05;
                const halfW = halfH * aspect;
                camera.left = -halfW;
                camera.right = halfW;
                camera.top = halfH;
                camera.bottom = -halfH;
                camera.near = 0.1;
                camera.far = radius * 20;
                const distance = radius * 3;
                controls.target.copy(center);
                camera.position.copy(center).add(currentDir.clone().multiplyScalar(distance));
            }
            camera.updateProjectionMatrix();
            controls.update();
        }

        // --- Window Zoom (click-move-click) ---
        function activateWindowZoom() {
            windowZoomActive = true;
            zoomDragStart = null; // 첫 번째 클릭 대기 상태
            if (controls) controls.enabled = false;
            if (renderer) renderer.domElement.style.cursor = 'crosshair';
            const btn = document.getElementById('btn-window-zoom');
            if (btn) {
                btn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            }
        }

        function deactivateWindowZoom() {
            windowZoomActive = false;
            zoomDragStart = null;
            if (renderer) renderer.domElement.style.cursor = 'default';
            const btn = document.getElementById('btn-window-zoom');
            if (btn) {
                btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                btn.classList.add('bg-gray-600', 'hover:bg-gray-700');
            }
            const rect = document.getElementById('zoom-selection-rect');
            if (rect) rect.style.display = 'none';
            if (controls) controls.enabled = true;
        }

        function onZoomClick(event) {
            if (!windowZoomActive || event.button !== 0) return;
            event.stopPropagation();
            event.preventDefault();
            const visRect = VIS_CONTAINER.getBoundingClientRect();
            const x = event.clientX - visRect.left;
            const y = event.clientY - visRect.top;

            if (!zoomDragStart) {
                // 첫 번째 클릭: 시작점 설정
                zoomDragStart = { x, y };
                const selRect = document.getElementById('zoom-selection-rect');
                if (selRect) {
                    selRect.style.display = 'block';
                    selRect.style.left = x + 'px';
                    selRect.style.top = y + 'px';
                    selRect.style.width = '0px';
                    selRect.style.height = '0px';
                }
            } else {
                // 두 번째 클릭: 윈도우 확정
                const left = Math.min(zoomDragStart.x, x);
                const top = Math.min(zoomDragStart.y, y);
                const width = Math.abs(x - zoomDragStart.x);
                const height = Math.abs(y - zoomDragStart.y);

                if (width > 10 && height > 10) {
                    performWindowZoom(left, top, width, height, visRect.width, visRect.height);
                }
                deactivateWindowZoom();
            }
        }

        function onZoomMouseMove(event) {
            if (!windowZoomActive || !zoomDragStart) return;
            const visRect = VIS_CONTAINER.getBoundingClientRect();
            const currentX = event.clientX - visRect.left;
            const currentY = event.clientY - visRect.top;
            const selRect = document.getElementById('zoom-selection-rect');
            if (selRect) {
                const left = Math.min(zoomDragStart.x, currentX);
                const top = Math.min(zoomDragStart.y, currentY);
                const width = Math.abs(currentX - zoomDragStart.x);
                const height = Math.abs(currentY - zoomDragStart.y);
                selRect.style.left = left + 'px';
                selRect.style.top = top + 'px';
                selRect.style.width = width + 'px';
                selRect.style.height = height + 'px';
            }
        }

        function performWindowZoom(left, top, width, height, viewWidth, viewHeight) {
            const oldDist = camera.position.distanceTo(controls.target);

            // 타겟 평면에서 실제로 보이는 3D 영역 크기
            let visibleH, visibleW;
            if (camera.isPerspectiveCamera) {
                const fovRad = camera.fov * Math.PI / 180;
                visibleH = 2 * oldDist * Math.tan(fovRad / 2);
                visibleW = visibleH * camera.aspect;
            } else {
                visibleH = camera.top - camera.bottom;
                visibleW = camera.right - camera.left;
            }

            // 윈도우 중심의 화면 중앙으로부터의 픽셀 오프셋
            const dxPx = (left + width / 2) - viewWidth / 2;
            const dyPx = (top + height / 2) - viewHeight / 2;

            // 픽셀 오프셋 → 3D 월드 오프셋
            const worldDx = (dxPx / viewWidth) * visibleW;
            const worldDy = -(dyPx / viewHeight) * visibleH;

            // 카메라의 right, up 벡터
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const camRight = new THREE.Vector3().crossVectors(camDir, camera.up).normalize();
            const camUp = new THREE.Vector3().crossVectors(camRight, camDir).normalize();

            // 패닝: 카메라와 타겟을 동일하게 이동
            const panOffset = new THREE.Vector3()
                .addScaledVector(camRight, worldDx)
                .addScaledVector(camUp, worldDy);
            controls.target.add(panOffset);
            camera.position.add(panOffset);

            // 줌
            const zoomFactor = Math.min(viewWidth / width, viewHeight / height);
            if (camera.isPerspectiveCamera) {
                const newDist = oldDist / zoomFactor;
                camera.position.copy(controls.target).addScaledVector(camDir, -newDist);
            } else {
                camera.left /= zoomFactor;
                camera.right /= zoomFactor;
                camera.top /= zoomFactor;
                camera.bottom /= zoomFactor;
            }

            camera.updateProjectionMatrix();
            controls.update();
        }

        // 8. DOM Content Loaded Event Handler
        document.addEventListener('DOMContentLoaded', () => {
            const loadButton = document.getElementById('load-button');
            const mctInput = document.getElementById('mct-input');
            const toggleLabelsCheckbox = document.getElementById('toggle-labels');

            // Theme: restore saved preference
            const themeSelect = document.getElementById('theme-select');
            const savedThemeOnLoad = localStorage.getItem('modelviewer-theme') || 'dark';
            themeSelect.value = savedThemeOnLoad;

            initScene();
            initAxisHelper();
            axisLabelEls = createAxisLabels();
            animate();

            // Apply theme after scene is ready
            applyTheme(savedThemeOnLoad);

            // Theme select change event
            themeSelect.addEventListener('change', () => {
                applyTheme(themeSelect.value);
            });

            // Fit All button
            document.getElementById('btn-fit-all').addEventListener('click', fitAll);

            // Window Zoom button (toggle)
            document.getElementById('btn-window-zoom').addEventListener('click', () => {
                if (camera.isPerspectiveCamera) {
                    alert('윈도우 줌 기능은 원근투영이 꺼진 상태에서만 작동합니다.');
                    return;
                }
                if (windowZoomActive) {
                    deactivateWindowZoom();
                } else {
                    activateWindowZoom();
                }
            });

            // Window Zoom mouse events on visualization container
            VIS_CONTAINER.addEventListener('click', onZoomClick, false);
            VIS_CONTAINER.addEventListener('mousemove', onZoomMouseMove, false);

            // ESC key to cancel window zoom
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && windowZoomActive) {
                    deactivateWindowZoom();
                }
            });

            // Perspective toggle
            document.getElementById('toggle-perspective').addEventListener('change', (e) => {
                switchCamera(e.target.checked);
            });

            // File Open Button
            const fileInput = document.getElementById('file-input');
            document.getElementById('file-open-button').addEventListener('click', () => {
                fileInput.click();
            });
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    mctInput.value = ev.target.result;
                    // 자동으로 로드 실행
                    loadButton.click();
                };
                reader.readAsText(file);
                fileInput.value = ''; // 같은 파일 재선택 가능하도록 초기화
            });

            // Load Button Click Event
            loadButton.addEventListener('click', () => {
                const rawData = mctInput.value;
                STATUS_MESSAGE.className = 'text-sm mt-2 text-gray-700';
                STATUS_MESSAGE.textContent = '데이터 로드 중...';
                
                setTimeout(() => {
                    try {
                        const data = parseMCT(rawData);
                        visualizeStructure(data);
                        
                    } catch (error) {
                        STATUS_MESSAGE.className = 'text-sm mt-2 text-red-600 font-semibold';
                        STATUS_MESSAGE.textContent = `오류: ${error.message}. 데이터를 확인해주세요.`;
                        console.error("Visualization Error:", error);
                    }
                }, 10); 
            });

            // Toggle Labels Checkbox Event
            toggleLabelsCheckbox.addEventListener('change', () => {
                updateLabels();
            });

            // Toggle Element Labels Checkbox Event
            const toggleElementLabelsCheckbox = document.getElementById('toggle-element-labels');
            toggleElementLabelsCheckbox.addEventListener('change', () => {
                updateLabels();
            });

            // Toggle Section Labels Checkbox Event
            const toggleSectionLabelsCheckbox = document.getElementById('toggle-section-labels');
            toggleSectionLabelsCheckbox.addEventListener('change', () => {
                updateLabels();
            });
        });

    </script>
</body>
</html>